# Из лекций и семинара понял что контейнеризация нужна для изоляции какого нибудь приложения с которым нужно провести тесты
# или просто ему не нужно много ресурсов и библиотек(зависимостей всяких), и получается что такое приложение было бы лучше
# держать отдельно в контейнере.

# Сперва заходим под рутом, так как почти все команды потребуют от нас админ прав
sudo su

# Приступаем к созданию своей изоляционной оболочки
# создадим ей необходимые папки
mkdir my_docker
mkdir my_docker/bin

# скопируем стандартную оболочку bash(с исполняемым файлом) в нашу изоляцию
cp /bin/bash my_docker/bin

# осталось скопировать зависимости для bash
# нам нужен список этих зависимостей и пути к ним
ldd /bin/bash

# создадим папки для будущих скопированных зависимостей
mkdir my_docker/lib
mkdir my_docker/lib64

# ну и копируем зависимости
cp /lib/x86_64-linux-gnu/libtinfo.so.6 my_docker/lib
cp /lib/x86_64-linux-gnu/libc.so.6 my_docker/lib
cp /lib64/ld-linux-x86-64.so.2 my_docker/lib64/

# теперь вызовем операцию смены корневого каталога для изоляции нашего процесса(оболочка bash)
chroot my_docker /bin/bash
# Готово!

# Чтобы можно было производить какие то манипуляции вроде просмотра папок и т.п.
# нужно так же посмотреть через ldd зависимости таких утилит
# и подгрузить их аналогично(как выше прописано начиная с ldd)

exit
# Если мы выходим из какого то пространства имён,
# к примеру изолированной оболочки, то она уничтожается.


# Далее попробуем создать сетевое пространство имён - подобие коммутатора(switch)
# нам понадобится утилита ip, для работы с сетью

# добавим через утилиту ip сетевое пространство с названием my_ns
ip netns add my_ns

# удостоверимся что создали наше сетевое пространство(сетевую папку) my_ns
ip netns list

# можем посмотреть на то какие IP адреса используются в текущий момент
ip a

# войдём в bash через наше сетевое пространство my_ns
ip netns exec my_ns bash

# снова смотрим на IP адреса и видим изменения...
ip a
# появилась изоляции от всей сети кроме loopback(localhost)

# посмотрим на процессы нашей системы
ps aux
# делаем вывод, что изоляция состоялась только на сеть

# выйдем с сетевой изоляции и попробуем ещё один пример

# утилита которая позволяет разграничивать что то из перечисленных параметров:
# net           - сетевое пространство
# pid           - дерево процессов
# fork          - память
# mount-proc    - разграничиваем процесс
unshare --net --pid --fork --mount-proc /bin/bash

# удостоверимся в этой утилите и посмотрим на процессы нашей системы
ps aux



