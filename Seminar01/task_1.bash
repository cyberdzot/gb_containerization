# Записи с семинара. Вызов chroot на практике.

Для этого создадим каталог "testfolder" в домашнем каталоге пользователя и запустим команду chroot.

# Создаем директорию "testfolder":

mkdir testfolder
# Копируем исполняемый файл командного интерпретатора /bin/bash в папку "testfolder/bin":

cp /bin/bash testfolder/bin
# Создаем необходимые директории "testfolder/lib" и "testfolder/lib64":

mkdir testfolder/lib
mkdir testfolder/lib64
# Копируем необходимые библиотеки в папку "testfolder/lib" и "testfolder/lib64". Пример:

cp /lib/x86_64-linux-gnu/libtinfo.so.6 testfolder/lib
cp /lib/x86_64-linux-gnu/libc.so.6 testfolder/lib
cp /lib64/ld-linux-x86-64.so.2 testfolder/lib64/
# Запускаем команду chroot для изменения корневой папки:

chroot testfolder /bin/bash
# Примечания:

# Важно убедиться, что пути к исполняемым файлам и библиотекам соответствуют вашей системе.
# В инструкции необходимо указать, что пользователь должен быть владельцем папки "testfolder" и иметь права на выполнение команды chroot.
# Удалены фрагменты, которые не содержат полезной информации или являются повторением уже ранее описанного.
# Это общая инструкция по использованию chroot, однако важно отметить, что chroot имеет свои ограничения и может не обеспечить полную изоляцию процессов. Если вам требуется более надежная изоляция, рекомендуется использовать более продвинутые инструменты, такие как контейнеризация с помощью Docker или виртуализация.4/

# Теперь можно попытаться сделать смену корня
chroot testfolder
# Сейчас все получилось. Можно увидеть что приветствие системы изменилось.
# Мы сменили в данном случае корневую папку , это по сути означает что мы изолировали процесс. По сути у Нас запустилась изолированная оболочка интерпретатора БАШ, с корнем отличным от файловой системы.
# Теперь когда все получилось можно посмотреть текущую директорию с помощью команды

ls
# bash: ls: command not found
# однако есть проблема, программа не найдена
# Вопрос. Почему получили эту ошибку.
# Ответ довольно прост, как и ранее необходимо скопировать все необходимые исполняемые файлы в созданную папку вместе с динамическими библиотеками, как было показано раньше.

new addition
cp /bin/ls testfolder/bin/
ldd /bin/ls
cp /lib/x86_64-linux-gnu/libselinux.so.1 testfolder/lib/
cp /lib/x86_64-linux-gnu/libpcre2-8.so.0 testfolder/lib/
chroot testfolder/
ls /

# Рассмотрев часть на практике , можно определить серьезный недостаток использования ЧенчжРут — При создании новой корневой директории , необходимо дублировать абсолютно все исполняемые файлы, что несомненно повлечет за собой рост заманиваемого дискового пространства.

# Перейдем к Механизму пространства имен, так как он лишен этих проблем.
# Пространство имен в системе Линукс, абстракция в которой находятся все системные ресурсы. Тип ресурса зависит от типа пространства имен. Пространство имен это не дополнительная функция которую можно установить или обойтись без нее. Это сущность которая изначально предоставляется самим ядром ОС и является необходимым компонентом, который принимает участие в процедуре запуска абсолютно любого процесса в системе. И в любой момент времени, любой процесс может принадлежать только одному пространству имен каждого типа. Так же Пространство имен это механизм который обеспечивает изоляцию процессов друг от друга в Юникс Системемах.

ip a

# Сетевое пространство имен. Самый простой вариант
ip netns list
ip netns add testns — создали
# команда — аргумент — команда - название
# ip — это утилита которая в целом позволяет работать с сетью в системе.
# Создаем пространство имен в ней
ip netns list — посмотрели
# testns — увидели и еще формально ничего не подключенно
# Это уже не папка в почти как Свитч — это такое устройство, которое формирует сеть, и в которое подключаются наши машинки через порты. Задача свитча L2 (есть ещё более продвинутые, относящиеся к L3 и даже к L7) — перенаправлять кадры от MAC отправителя к MAC получателя. Множество машин, подключенных к одному свитчу формируют локальную сеть (LAN).
# Ip — просмотр команд
# ip netns help — просмотр команд

# Но пока пустой, когда выполняем эту команду
ip netns exec testns bash -
# подключи такому свичу такой процесс
# вот баш(программный интерпретатор) я хочу с ним поработать так, чтобы он был изолирован.
Ip a
# Формально к нашему комутатору подключаеться ноутбук
# Мы можем посмотреть только выдалось нам что то или нет, так как по факту там ничего нет потому что у нас нет дспчСервера который бы что то выдал ну и вообще ничего нет.
# При этом мы остаемся в своей хостовой системе
ps aux
# Он выведет абсолютно все
ip a
# Но мы изолированы именно в сетевом пространстве имен
# Как пример, в теории так мы могли изолировать подключение к устройству

# Как проверить где мы?
ip netns exec testns bash -
# Когда мы это сказали, он нас отправил в этот НеймСпейс

# аналог нашего АйПи для пространства имен
unshare —net /bin/bash
ip a
# мы сейчас в пространсве имен, который ограничен только по сетевому пространству
ps aux
# мы ввели ps aux и весь набор процессов

# теперь выйдем от сюда,и ограничим дополнительно.
unshare --net --pid --fork --mount-proc /bin/bash
ps aux
# unshare Утилита которая позволяет это разграничивать -
# --net — ограничевает сетевое пространство имен
ip a
# -mount-proc — разграничивает процессы
ps aux
# --fork — изолирует память
# --pid — изолирует дерево процессов

# Формально мы внутри контейнера
ls
ls /

ps aux